classdef randomcharges < handle
    %CHARGES Summary of this class goes here
    %   Detailed explanation goes here
    
    properties
        Charges
    end
    
    methods
        function self = randomcharges()
            for i = 1:1
                self.Charges = [self.Charges struct( ...
                    'x', self.getRandomNumberInRange(0, constants.PLOT_SIZE), ...
                    'y', self.getRandomNumberInRange(0, constants.PLOT_SIZE), ...
                    'charge', self.getRandomNumberInRange(-10, 20), ...
                    'mass', self.getRandomNumberInRange(0, 30), ...
                    'vx', self.getRandomNumberInRange(-20, 20), ...
                    'vy', self.getRandomNumberInRange(-20, 20), ...
                    'ax', self.getRandomNumberInRange(-20, 20), ... 
                    'ay', self.getRandomNumberInRange(-20, 20))];
            end
        end

        function [r] = get.Charges(self)
                r = self.Charges;
        end 

        function [r] = getRandomNumberInRange(~, min, max)
                r = (max-min).*rand(1,1) + min;
        end

        function [ex, ey] = getPole(x, y, inputData)
            for data = inputData
                r = sqrt(pow2(x - data.x) + pow2(y - data.y));

                e = constants.K * data.charge / r;
               
                ex = ex + (e * (x - data.x) / r);
                ey = ey + (e * (y - data.y) / r);
            end
        end

        function Update(self, inputData)
             for i = 1:length(self.Charges)
                [ex, ey] = self.getPole(self.Charges(i).x, self.Charges(i).y, inputData);
                


                self.Charges(i).x = self.Charges(i).x + ();
             end

%             // if the charge is too close to a stationary charge, field_intensity_movable returns Inf for all values
%             // thus why we check only one of them
%             // in that case, we don't want to update the charge's position
%             if intensity.x.is_infinite() {
%                 println!("Kolizja");
%                 movable_charge.collided = true;
%                 movable_charge.should_move = false;
%                 continue;
%             }
% 
%             movable_charge.x +=
%                 (movable_charge.v.x * delta_t) + (0.5 * movable_charge.a.x * delta_t.powi(2));
%             movable_charge.y +=
%                 (movable_charge.v.y * delta_t) + (0.5 * movable_charge.a.y * delta_t.powi(2));
% 
%             movable_charge.v.x += movable_charge.a.x * delta_t;
%             movable_charge.v.y += movable_charge.a.y * delta_t;
% 
%             movable_charge.a.x = intensity.x * movable_charge.q / movable_charge.m;
%             movable_charge.a.y = intensity.y * movable_charge.q / movable_charge.m;
% 
%             if self.track_movement {
%                 self.movement_history[i].push(MovementStep {
%                     x: movable_charge.x,
%                     y: movable_charge.y,
%                     a: movable_charge.a.clone(),
%                     v: movable_charge.v.clone(),
%                 });
%             }
        end
    end
end

